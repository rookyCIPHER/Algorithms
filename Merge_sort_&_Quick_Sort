int* swap(int* arr, int i1, int i2){   //i1 and i2 are the two indexes to be swapped
   int a=arr[i1];
   arr[i1]=arr[i2];
   arr[i2]=a;
   return arr;
}

void swap(int &x, int &y)
{
    int temp = x;
    x = y;
    y = temp;
}



/*
//
void merge(int* arr1, int* arr2, int n){
    int i=0;
    int j=0;
    int k=0;
    int ptr[2*n];

    while(i<n && j<n){

       if(arr1[i]<arr2[j]){
         ptr[k]=arr1[i];
         i++;
       } else {
         ptr[k]=arr2[j];
         j++;
       }
       k++;
    }
   
    for( ;i<n;i++){
        ptr[k]=arr1[i];
        k++;
    }

    for( ;j<n;j++){
        ptr[k]=arr2[j];
        k++;
    }

}

//merge sort
void merge_sort(int* arr, int start, int end){
    int ptr[end-start+1];

    if((end-start)+1==2){ //base case
        if(arr[start]>arr[end]){
            swap(arr,start,end);
            ptr[start]=arr[start];
            ptr[end]=arr[end];
        }
    }

    int ptr1[((start+end)/2)+1];
    int ptr2[((start-end)/2)+1];

    merge_sort(arr,start,(start+end)/2);
    merge_sort(arr,((start+end)/2)+1,end);
    merge(ptr1,ptr2,((end-start)/2)+1);

}
*/


// merge sort
void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];
 

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];


    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
 
    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] < R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
 
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
 

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
 

void mergeSort(int arr[], int l, int r)
{
    if (l < r) {
        // Same as (l+r)/2, but avoids overflow for
        // large l and h
        int m = l + (r - l) / 2;
 

        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
 
        merge(arr, l, m, r);
    }
}


//quick sort

int partition(int arr[], int low, int high)
{
    int pivot = arr[high]; // pivot
    int i
        = (low
           - 1); // Index of smaller element and indicates
                 // the right position of pivot found so far
  
    for (int j = low; j <= high - 1; j++) {
        // If current element is smaller than the pivot
        if (arr[j] < pivot) {
            i++; // increment index of smaller element
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}
  
/* The main function that implements QuickSort
arr[] --> Array to be sorted,
low --> Starting index,
high --> Ending index */
void quickSort(int arr[], int low, int high)
{
    if (low < high) {
        /* pi is partitioning index, arr[p] is now
        at right place */
        int pi = partition(arr, low, high);
  
        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
